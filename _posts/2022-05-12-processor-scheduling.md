# 단일프로세서 스케쥴링

과목: 운영체제
날짜: 2022년 2월 25일

![제목 없음.png](%EC%A0%9C%EB%AA%A9_%EC%97%86%EC%9D%8C.png)

---

## 스케쥴링

💡 프로세스(작업)에 프로세서를 할당하는 일련의 과정

- 여러 프로세스가 번갈아 사용하는 자원을 어떤 시점에서 어떤 프로세스에 할당할지를 결정하는 것
- 작업의 응답 시간 최소화

<br>

### **_왜_ 필요할까?**

- 공정성, 처리율 증가, CPU 이용률 증가, 우선순위 제도, 오버헤드 최소화
- 응답시간, 반환시간, 대기시간 최소화
- 균형 있는 자원의 사용, 무한 연기 회피

<br>

### 스케줄러의 종류

1. **작업 스케줄러(Job Scheduler) : 장기 스케줄러**

   ① 디스크 공간에 제출된 프로세스들(실행할 작업)을 준비 큐(입력 큐)에서 선택하여 주기억장치로 적재

   ② CPU 위주의 연산과 I/O 위주의 연산을 적절히 혼용하여 스케줄링함

2. **프로세스 스케줄러(Process Scheduler) : 단기 스케줄러**

   ① 메인 메모리의 준비 상태에 있는 작업들 즉, 실행 준비가 되어 있는 프로세스 중에서 하나를 선택하여 CPU를 할당함

   ![Untitled](Untitled.png)

<br>

### 스케줄링의 방법별 분류

💡 **실행 중인 작업이나 프로세스를 실행 중 중단할 것인가?** 의 관점을 기반으로 구분

1. **비선점 스케줄링**

   > FCFS, SJF, HRN, 우선순위, 기한부 알고리즘

   - 한 프로세스가 CPU를 할당받으면 CPU는 그 프로세스로부터 빠져 나올 수 없음 (이미 할당된 CPU를 다른 프로세스가 **강제로 빼앗아 사용할 수 없음**)
   - 응답시간을 쉽게 예측할 수 있음
   - 짧은 작업이 긴 작업을 기다리는 경우나, 중요한 작업이 기다려야하는 경우가 발생할 수 있음

2. **선점 스케줄링**

   > 선점 우선순위, SRT, RR, 다단계 큐, 다단계 피드백 큐

   - 한 프로세스가 CPU를 차지하고 있을 때 우선순위가 높은 다른 프로세스가 현재 프로세스를 중지시키고 **강제로 빼앗아 자신이 CPU를 차지할 수 있음**
   - 높은 **우선순위**를 가진 프로세스들을 빠르게 처리할 수 있기 때문에 이를 요구하는 대화형 시스템에서 유용함
   - 인터럽트와 문맥교환에 따른 많은 오버헤드가 발생

<br>

## 스케줄링 알고리즘

💡
**FCFS : RR
SJF : SRT
SJF >> HRN
다단계 큐 >> 다단계 피드백 큐**

</aside>

<br>

### FCFS 스케줄링 - 비선점

- First Come First Service
- 가장 간단한 기법
- 준비큐에 **도착한 순서에 따라** CPU를 할당받음

  예시)

  다음과 같은 상태가 있다고 하자. 들어온 순서는 P1→P2→P3 이다.

  | 프로세스 | 실행시간 |
  | -------- | -------- |
  | P1       | 24       |
  | P2       | 3        |
  | P3       | 3        |

- FCFS 알고리즘에 따라 아래와 같이 들어온 순서인 **P1 → P2 → P3** 순으로 CPU를 요청하고, 시간을 사용한다.

  ![Untitled](Untitled%201.png)

- P3는 P1보다 실행시간이 짧지만, CPU를 늦게 요청했기 때문에 총 걸리는 시간이 길다.
- **평균 대기시간** : (0 + 24 + 27) / 3 = 17
- **평균 반환시간** : (24 + 27 + 30) / 3 = 27

<br>

### RR 스케줄링 - 선점

- Round Robin \*\*\*\*
- **FCFS에 의해서** 프로세스들이 내보내어지며, 각 프로세스는 같은 크기의 CPU 시간(Time Slice)을 할당함

    <aside>

  **Time Slice의 크기**

  - Time Slice가 너무 **_크면_** FCFS와 동일해진다. (다른 프로세스는 CPU에 굶주리는 현상이 일어날 수 있음)
  - Time Slice가 너무 **_작으면_** 많은 문맥교환으로 CPU 유휴시간이 증가된다.

    </aside>

    예시)

    다음과 같은 상태가 있다고 하자. 프로세스가 CPU를 사용할 수 있는 **Time Slice는 4**로 가정한다.

    | 프로세스 | 도착시간 | 실행시간 |
    | -------- | -------- | -------- |
    | P1       | 0        | 8        |
    | P2       | 1        | 4        |
    | P3       | 2        | 9        |
    | P4       | 3        | 5        |

    **<동작>**

    ![IMG_E7D31C0C9FCC-1.jpeg](IMG_E7D31C0C9FCC-1.jpeg)

    - **평균 대기시간** : ((16-4) + (4-1) + (8-2)+(20-12)+(25-24)+ (12-3)+(24-16)) / 4 = 11.75
    - **평균 반환시간** : (20 + (8-1) + (26-2) + (25-3)) / 4 = 18.25

<br>

### SJF 스케줄링 - 비선점

- Shorted Job First
- 기다리고 있는 작업 중에서 **수행시간이 가장 짧은 프로세스**에게 먼저 할당하는 기법
- **가장 적은 평균 대기 시간**을 제공하는 최적 알고리즘
- 실행 시간이 긴 프로세스는 실행 시간이 짧은 프로세스에게 할당 순위가 밀려 무한 연기 상태가 발생할 수 있음

  예시)

  다음과 같은 상태가 있다고 하자.

  | 프로세스 | 도착시간 | 실행시간 |
  | -------- | -------- | -------- |
  | P1       | 0        | 8        |
  | P2       | 1        | 4        |
  | P3       | 2        | 9        |
  | P4       | 3        | 5        |

  **<동작>**

  ![Untitled](Untitled%202.png)

  - **평균 대기시간** : (0 + (8-1) + (17-2) + (12-3)) / 4 = 7.75
  - **평균 반환시간** : (8 + (12-1) + (26-2) + (17-3)) / 4 = 14.25

<br>

### SRT 스케줄링 - 선점

- Shortest Remaining Time
- 비선점 스케줄링 SJF를 선점 형태로 변경 (**선점 SJF 기법**)
- SJF와 마찬가지로 새로 도착한 프로세스를 포함하여 처리가 완료되는데 가장 짧은 시간이 소요된다고 판단되는 프로세스를 먼저 수행
- 시분할 시스템에 유용

  예시)

  다음과 같은 상태가 있다고 하자.

  | 프로세스 | 도착시간 | 실행시간 |
  | -------- | -------- | -------- |
  | P1       | 0        | 8        |
  | P2       | 1        | 4        |
  | P3       | 2        | 9        |
  | P4       | 3        | 5        |

  **<동작>**

  ![Untitled](Untitled%203.png)

  - **평균 대기 시간** : ((10-1) + (1-1) + (17-2) + (5-3)) / 4 = 6.5
  - **평균 반환 시간** : ((17 + (5-1) + (26-2) + (10-3)) / 4 =13

### HRN 스케줄링 - 비선점

- Hightest Response-ratio Next
- **SJF**의 약점이었던 긴 작업과 짧은 작업간의 지나친 불평등을 **어느 정도 보완**한 기법
- 우선순위 계산 공식을 이용하여 서비스(실행) 시간이 짧은 프로세스나 대기 시간이 긴 프로세스에게 우선순위를 주어 CPU를 할당
- 서비스 실행 시간이 짧거나 대기 시간이 긴 프로세스의 경우 우선순위가 높아짐
- 우선순위를 계산하여 그 숫자가 가장 높은 것부터 낮은 순으로 우선순위가 부여됨
- **우선순위 공식**
  ![Untitled](Untitled%204.png)

### 다단계 큐 알고리즘 - 선점

- MLQ : Multi-Level Queue
- 각 작업들이 **_서로 다른 묶음_** 으로 분류될 수 있을 때 사용

![Untitled](Untitled%205.png)

- 준비상태 큐를 여러 단계 종류로 분할해둠
- 기억장치의 크기나 프로세스 형태에 따라 어느 한 큐에 지정됨. 이 후 작업은 다른 큐로 이동할 수 없음
- **큐들 간의 프로세스 이동이 불가**하기 때문에 스케줄링 부담이 적지만 **유연성이 떨어짐** ⇒ 이를 보완한 게 다단계 피드백 큐
- **항상 가장 높은 우선순위 큐의 프로세스에 CPU를 할당** (우선순위가 낮은 큐에서 작업 실행 중이더라도 상위 단계의 큐에 프로세스가 도착하면 CPU를 빼앗음 ⇒ 선점)
- 각 큐는 라운드 로빈이나 FCFS등 독자적 스케줄링 사용 가능
- 대화형, 배치 등의 프로세스 성격에 따라 우선순위 부여
- 작업을 전면작업(대화형)과 후면작업(일괄처리형) 으로 분류한다면 이 두 작업은 각각 요구 반응 시간이 다르므로 서로 다르게 스케줄링 되어야 함
- 일반적으로 대화형을 중요하게, 백그라운드(일괄처리형 배치)는 상대적으로 덜 중요하다고 분류함
- 우선순위가 낮은 프로세스가 오랫동안 CPU 할당을 기다리는 **기아 현생 발생 가능**

### 왜 이렇게 쪼개서 다른 스케줄링 기법을 적용하는가?

- 우리와 interactive하게 작동하는 프로세스는 요구되는 응답시간이 백그라운드 프로세스보다 당연히 더 짧음
  - 구글링할때 페이지 바로바로 안뜨면 빡쳐서 끔
  - 그러나 압축풀기나 프로그램 다운로드는 실행시켜놓고 오래걸려도 신경안쓰고 다른 일함
    ⇒ **앞단의 프로세스들은 백그라운드에서 조용히 돌아가는 프로세스들보다 더 높은 우선순위를 갖게되고, 빠른 응답을 주기 위해 당연히 다른 알고리즘이 적용되어야 더 효율적으로 성능을 끌어낼 수 있음**

![Untitled](Untitled%205.png)

- 일괄처리(background) 프로세스는 보통 **FCFS 알고리즘**이 작동
  ex) 온라인 홈쇼핑에서 쇼핑하는동안 뒤에서 다운로드는 쭉 끝날때까지 선점당하지 않고 한 번에 실행되어야 하니까
- 우선순위가 높은 대화식(foreground) queue에는 **RR알고리즘** 적용
  ex) 내가 쇼핑하는데 CPU가 자꾸 다른 프로세스 처리하느라 로딩이 느려지면 짜증나니까 선점해야함

참고로 학생프로세스가 가장 최하위 ㅎㅎㅎㅎ

운영체제는 우리가 만들어내는 것들을 가장 **_하찮게_** 생각합니다 ㅋ

### 다단계 피드백 큐 알고리즘 - 선점

- MFQ : Multi-level Feedback Queue

![Untitled](Untitled%206.png)

- 다단계 큐 + 동적인 프로세스 우선 순위 변화 적용
- 프로세스 생성 시 가장 높은 우선 순위 준비 큐에 등록되며 등록된 프로세스는 **FCFS 순서**로 CPU를 할당받아 실행됨. 해당 큐의 CPU 시간 할당량이 끝나면 한 단계 아래의 준비 큐에 들어감
- **단계가 내려갈수록 시간 할당량 증가**
- 큐 사이의 프로세스 이동이 가능하며, CPU 사용 시간에 따라 **입출력 위주와 CPU 위주로 구분하여 특성에 따른 서로 다른 Time-Slice를 부여함**
- 입출력 장치를 효과적으로 이용하기 위해 **입출력 위주의 작업들에게 우선권**을 줌
- 가장 하위 큐는 FCFS 스케줄링
- 맨 아래 큐에서 너무 오래 대기하면 다시 상위 큐로 이동 (**에이징 기법을 통한 기아상태 예방**)

<aside>
💡 ***Aging 방식 (에이징)*** 이란?

- interactive한 (우선순위가 높은) 프로세스가 계속해서 들어올 때 ⇒ 큐만 주구장창 수행되고 낮은 우선순위는 밀림 : 이것이 바로 **starvation (기아현상)**

- 위 현상을 해결하기 위한 방식

- 낮은 우선순위 큐에서 너무 오래 기다리는 프로세스들을 높은 우선순위 큐에 다시 갖다둠

</aside>

- CPU Burst(CPU 실행시간)는 낮은 우선순위의 큐, I/O Burst(입출력을 요청한 다음 기다리는 시간)는 높은 우선순위의 큐에 배치
  ![Untitled](Untitled%207.png)
  - 이 특징은 CPU burst와 중요도의 상관관계를 발견한데서 있음
  - 보통 사용자와 **interactive 하지 않은, background의 프로세스는 CPU burst가 매우 크다**는 특징을 이용한 것
    예를들어, 사양이 엄청 큰 게임을 다운로드한다고 생각해보자.
    그 게임을 다운로드하는 데 적어도 30분은 기다려야한다고 하면 우리는 마냥 기다리는 것이 아닌 다운 받는 도중에 인터넷서칭을 함
    이 때 바로바로 처리해야할 일은 인터넷 서칭이 됨.
  - 게임 다운로드처럼 CPU를 계속 써야하는, CPU burst가 큰 프로세스를 우선순위가 낮다고 판별
  - 나와 상호작용할 가능성이 높은 프로세스, 내 입출력을 필요로 하는 (마우스나 키보드) 이런 애들은 CPU처리가 I/O 작업이랑 번갈아가면서 일어나므로 CPU Burst가 작음 ⇒ 우선순위가 높다! 라는 특징을 활용한게 다단계 피드백 큐

💡 다단계 큐와 다단계 피드백 큐의 **차이점** 이 뭔가요?
A. 가장 큰 차이점은 MLQ의 경우 **큐와 큐 사이에 프로세스들이 이동**을 할 수 없는 반면에, MFQ는 할 수 있음. 따라서 MFQ에 비해 MLQ는 스케줄링 부담이 적지만 유연성은 떨어짐. 또한 MLQ의 경우 하위 단계 큐에 있을 수록 CPU 할당을 받지 못하여 기아 현상이 발생할 수도 있는 반면, MFQ는 에이징 기법을 통해 **기아 현상**을 예방할 수 있음

### 이렇게 복잡한데 _왜_ 쓰는걸까?

1. 유연성이 뛰어남
2. SJF 알고리즘처럼평균 대기 시간에 최적화되어 있음 (time-quantum 을 보고 우선순위를 예측하고 변경 ⇒ 더 짧은 프로세스가 먼저 돌게 해줌)
3. interactive한 프로세스가 앞에 오기 때문에 반환시간이 짧아짐

### 기한부 알고리즘 - 비선점

- DeadLine
- 프로세스에게 **_일정한 시간_** 을 주고 그 시간 안에 프로세스를 완료하도록 하는 기법
- 프로세스가 제한된 시간 안에 **완료되지 않을 경우 제거되거나 처음부터 다시 실행**해야 함
- 시스템은 프로세스에게 할당할 정확한 시간을 추정해야하며, 이를 위해 사용자는 시스템이 요구한 프로세스에 대해 정확한 정보를 제공해야 함
- 여러 프로세스들이 동시에 실행되면 스케줄링이 복잡해지며, 프로세스 실행 시 집중적으로 요구되는 자원 관리에 오버해드가 발생

### 우선순위 - 비선점

- Priority
- 준비상태 큐에서 기다리는 **각 프로세스마다 _우선순위_ 를 부여**하여 그 중 가장 높은 프로세스에게 먼저 CPU를 할당하는 기법
- 우선순위가 동일할 경우 FCFS 기법으로 CPU 할당
- 우선순위는 프로세스의 종류나 특성에 따라 다르게 부여될 수 있음
- 가장 낮은 순위를 부여받은 프로세스는 무한 연기 또는 **기아 상태(Starvation)이 발생**할 수 있음

---

### 문제를 한 번 풀어볼까요?

- 문제 1

  Q. 하나의 프로세스가 CPU를 할당받은 후에 스스로 CPU를 반납할 때까지 다른 프로세스가 CPU를 차지할 수 없도록 하는 스케줄링 기법에 해당하는 것만을 모두 고르면?

  ㄱ. FCFS
  ㄴ. RR
  ㄷ. SRT

- 문제 2

  Q. HRN 방식으로 CPU스케줄링을 할 경우 입력된 작업이 다음과 같을 때, 우선순위가 가장 높은 작업은?
  | 작업 | 대기 시간 | 서비스 시간 |
  | ---- | --------- | ----------- |
  | A | 7 | 7 |
  | B | 10 | 5 |
  | C | 15 | 6 |
  | D | 21 | 10 |

- 문제 3

  Q. 다음 프로세스 P1~P4를 SJF 기법으로 스케줄링하였다. 각 프로세스의 대기 시간의 합은?
  | 프로세스 | 도착시간 | 실행시간 |
  | -------- | -------- | -------- |
  | P1 | 0 | 9 |
  | P2 | 1 | 5 |
  | P3 | 2 | 8 |
  | P4 | 3 | 3 |

- 문제 4

  Q. 다음과 같이 5개의 프로세스가 있다고 가정한다. 각 프로세스의 도착 시간과 프로세스의 실행에 필요한 시간은 아래표와 같다. CPU 스케줄링 알고리즘으로 RR을 사용한다고 가정한다. 평균 대기시간은 얼마인가? (단, 시간 할당량은 10초이다)
  | 프로세스 | 도착시간 | 실행시간 |
  | -------- | -------- | -------- |
  | 1 | 0 | 10 |
  | 2 | 6 | 18 |
  | 3 | 14 | 5 |
  | 4 | 15 | 12 |
  | 5 | 19 | 1 |

- 문제 5

  Q. 다단계 피드백 큐 설명으로 옳지 않은 것은?

  1. 대화형 프로세스들은 상위 단계의 큐에 주로 머물게 되고 배치(batch) 프로세스는 하위 단계 큐에 머문다
  2. 프로세스 성격에 따라 적응적 스케줄링이 가능하다
  3. 상위 단계 큐에서 하위 단계 큐로 갈수록 할당시간 (time quantum)이 길어진다
  4. 주로 실시간 OS에 적합하다

- 문제 6

  Q. 운영체제의 스케줄링 기법에 대한 설명으로 옳지 않은 것은?

  1. FCFS 스케줄링은 비선점 방식으로 실행중인 프로세스가 종료하면 준비 큐에서 가장 오래 대기한 프로세스를 다음 실행 프로세스로 선정한다
  2. RR 스케줄링은 선점 방식으로 프로세스를 정해진 시간 할당량만큼 실행 후 종료하지 못하면 준비 큐로 이동시킨다
  3. 비선점 SJF 스케줄링은 준비 큐에서 예상 전체 실행시간이 가장 짧은 프로세스를 다음 실행 프로세스로 선정한다
  4. 선점 SJF 스케줄링은 SRT 스케줄링이라고 불리며 비선점 SJF 스케줄링에서 발생할 수 있는 기아상태 문제를 해결한다

- 문제 7

  Q. 다음 중 기아(starvation) 현상이 발생할 수 있는 스케줄링 기법으로 옳은 것을 모두 고르면?

  ㄱ. FCFS
  ㄴ. RR
  ㄷ. Priority
  ㄹ. HRN
  ㅁ. SJF

- 정답
  1. ㄱ
  2. C
  3. 32
  4. 12.2초
  5. 1번
  6. 4
  7. ㄷ,ㅁ

다단계 큐 / 다단계 피드백 큐 쉬운 설명이 들어있는 참고 자료 첨부합니다

[https://jhnyang.tistory.com/28](https://jhnyang.tistory.com/28)

[https://jhnyang.tistory.com/156](https://jhnyang.tistory.com/156)
